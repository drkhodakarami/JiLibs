import groovy.json.JsonSlurper
import org.gradle.api.GradleException
import org.gradle.api.DefaultTask
import org.gradle.api.provider.Property
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.Internal

/*
 * Improved module validation script for JiLibs
 *
 * Changes and fixes applied:
 * - Prefer the expanded resource in build/resources/main/fabric.mod.json when validating.
 * - Detect unresolved placeholders (e.g. ${loader_version}) and emit a clear error.
 * - Use task registration that sets task inputs explicitly (loader/minecraft versions pulled from rootProject properties).
 * - Ensure validateModules depends on processResources when present so expansion runs first.
 * - Keep behavior of skipping meta projects (jilibs-bom, jilibs-catalog).
 * - Provide clearer, actionable error messages.
 *
 * Place this file under gradle/module-validation.gradle and apply it early in your root build.gradle:
 *   apply from: rootProject.file('gradle/module-validation.gradle')
 *
 * Usage:
 * - For IDE import generation, keep -PskipFolderInit (or similar) as needed; this script is defensive and will
 *   tell you to re-run with -Ploader_version if the property is missing.
 */

/**
 * Helper to find the file that should be validated. Prefer generated (expanded) resource.
 */
def findFabricModJsonFile(org.gradle.api.Project proj) {
    def expanded = proj.file("${proj.buildDir}/resources/main/fabric.mod.json")
    if (expanded.exists()) {
        return expanded
    }
    def source = proj.file("src/main/resources/fabric.mod.json")
    if (source.exists()) {
        return source
    }
    def clientSource = proj.file("src/client/resources/fabric.mod.json")
    if (clientSource.exists()) {
        return clientSource
    }
    return null
}

subprojects {
    // Skip meta projects
    if (it.name == "jilibs-bom" || it.name == "jilibs-catalog") {
        return
    }

    // Register the validation task for each subproject
    def validateModules = it.tasks.register("validateModules", ValidateModuleTask) { t ->
        // set inputs for the task: prefer explicit project properties, fallback to root project properties
        t.projectName.set(it.name)
        t.projectPath.set(it.path)
        // use string values; default to empty string if not present
        def loaderVal = (it.findProperty('loader_version') ?: it.rootProject.findProperty('loader_version') ?: "").toString()
        def mcVal = (it.findProperty('minecraft_version') ?: it.rootProject.findProperty('minecraft_version') ?: "").toString()
        t.loaderVersion.set(loaderVal)
        t.minecraftVersion.set(mcVal)

        // set fmj to the source template (task will prefer built expanded file when validating)
        def candidate = it.file("src/main/resources/fabric.mod.json")
        if (!candidate.exists()) {
            candidate = it.file("src/client/resources/fabric.mod.json")
        }
        t.fmj.set(candidate)

        // Ensure processResources runs before validation if it exists in the project
        def proc = it.tasks.findByName('processResources')
        if (proc != null) {
            t.dependsOn proc
        }
    }

    // Make the project's check task depend on validateModules
    it.tasks.matching { it.name == 'check' }.configureEach { checkTask ->
        checkTask.dependsOn validateModules
    }
}

/**
 * Validates a single module's fabric.mod.json for the expected values.
 */
abstract class ValidateModuleTask extends DefaultTask {
    @InputFile
    abstract RegularFileProperty getFmj()

    @Input
    abstract Property<String> getProjectName()

    @Input
    abstract Property<String> getProjectPath()

    @Input
    abstract Property<String> getLoaderVersion()

    @Input
    abstract Property<String> getMinecraftVersion()

    ValidateModuleTask() {
        group = "verification"
        description = "Validate fabric.mod.json for module lifecycle and dependency versions"

        // This task has no outputs; always evaluate when requested
        outputs.upToDateWhen { false }
    }

    @TaskAction
    void validate() {
        // Prefer expanded resource in build dir; otherwise use the fmj input (source/template)
        def expanded = project.file("${project.buildDir}/resources/main/fabric.mod.json")
        def fileToRead = null
        if (expanded.exists()) {
            fileToRead = expanded
        } else if (fmj.getOrNull() != null && fmj.get().asFile.exists()) {
            fileToRead = fmj.get().asFile
        } else {
            throw new GradleException("validateModules: fabric.mod.json not found for project ${project.name} (checked build/resources/main and src/.../resources).")
        }

        logger.lifecycle("validateModules: validating ${project.path} using ${fileToRead}")

        def json
        try {
            json = new JsonSlurper().parseText(fileToRead.getText('UTF-8'))
        } catch (Exception e) {
            throw new GradleException("validateModules: failed to parse ${fileToRead}: ${e.message}", e)
        }

        if (json == null) {
            throw new GradleException("validateModules: ${fileToRead} did not contain valid JSON")
        }

        if (json.depends == null) {
            throw new GradleException("Module ${projectName.get()} does not have a depends value in ${fileToRead}!")
        }

        // Helper to detect unresolved placeholders like ${loader_version}
        def containsPlaceholder = { val ->
            if (val == null) return false
            return val.toString().matches(/.*\$\{.+\}.*/)
        }

        // Validate fabricloader
        def loaderDeclared = json.depends?.fabricloader
        if (loaderDeclared == null) {
            throw new GradleException("Module ${projectName.get()} does not declare depends.fabricloader in ${fileToRead}.")
        }
        if (containsPlaceholder(loaderDeclared)) {
            throw new GradleException("Module ${projectName.get()} has unresolved placeholder in depends.fabricloader (${loaderDeclared}) — this means resource expansion didn't replace ${'${loader_version}'}. " +
                    "Ensure ProcessResources expanded fabric.mod.json (property 'loader_version' is set on the root project) or run Gradle with -Ploader_version=<version>.")
        }

        def expectedLoader = ">=${loaderVersion.get() ?: ''}"
        if (loaderDeclared.toString() != expectedLoader) {
            throw new GradleException("Module ${projectName.get()} does not have a valid fabricloader value! Got \"${loaderDeclared}\" but expected \"${expectedLoader}\"")
        }

        // Validate minecraft
        def mcDeclared = json.depends?.minecraft
        if (mcDeclared == null) {
            throw new GradleException("Module ${projectName.get()} does not declare depends.minecraft in ${fileToRead}.")
        }
        if (containsPlaceholder(mcDeclared)) {
            throw new GradleException("Module ${projectName.get()} has unresolved placeholder in depends.minecraft (${mcDeclared}) — this means resource expansion didn't replace ${'${minecraft_version}'}. " +
                    "Ensure ProcessResources expanded fabric.mod.json (property 'minecraft_version' is set on the root project) or run Gradle with -Pminecraft_version=<version>.")
        }

        def expectedMc = "~${minecraftVersion.get() ?: ''}"
        if (mcDeclared.toString() != expectedMc) {
            throw new GradleException("Module ${projectName.get()} does not have a valid minecraft version value! Got \"${mcDeclared}\" but expected \"${expectedMc}\"")
        }

        logger.lifecycle("validateModules: ${project.path} fabric.mod.json OK")
    }
}