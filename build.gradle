plugins {
    id "java-library"
    id "eclipse"
    id "maven-publish"
    id "fabric-loom" version "${loom_version}" apply false
    id 'com.diffplug.spotless' version "8.1.0"
}

import com.diffplug.spotless.LineEnding

//======================================================================================== READ LOCAL PROPERTIES
//============================================================== REPSY MAVEN
def ENV = System.getenv()
def systemRepsyURL = ENV.REPSY_URL
def systemRepsyUsername = ENV.REPSY_USERNAME
def systemRepsyPassword = ENV.REPSY_PASSWORD

Properties properties = new Properties()
def propertiesFile = project.rootProject.file('local.properties')
if (propertiesFile.exists())
    properties.load(propertiesFile.newDataInputStream())

project.ext {
    localRepsyUrl = properties.getProperty('REPSY_URL')
    localRepsyUsername = properties.getProperty('REPSY_USERNAME')
    localRepsyPassword = properties.getProperty('REPSY_PASSWORD')
}

def repsyUrl = project.ext.localRepsyUrl ?: systemRepsyURL
def repsyUsername = project.ext.localRepsyUsername ?: systemRepsyUsername
def repsyPassword = project.ext.localRepsyPassword ?: systemRepsyPassword
//============================================================== CURSEFORGE
//============================================================== MODRINTH
//============================================================== GITHUB

//======================================================================================== SETUP BASICS
def isCi = providers.environmentVariable("CI").present || project.hasProperty("ci")

def branchProvider = providers.of(GitBranchValueSource.class) {}

def getBranchSafe = {
    try {
        return branchProvider.get().replace("/", "_")
    } catch (Exception e) {
        logger.warn("Could not determine git branch for CI suffix: " + e.message)
        return "unknown"
    }
}

version = project.version + "+MC-${minecraft_version}"//-" + (isCi ? getBranchSafe() : "local")
logger.lifecycle("==============================================================================")
logger.lifecycle(">>> >>> >>> >>> >>> >>> Building Ji Libs: " + version)
logger.lifecycle("==============================================================================")

def metaProjects = [
        'jilibs-bom',
        'jilibs-catalog'
]

def debugArgs = [
        "-enableassertions",
        "-Dmixin.debug.verify=true",
        //"-Dmixin.debug.strict=true",
        "-Dmixin.debug.countInjections=true",
]

import groovy.json.JsonSlurper
import org.apache.commons.codec.digest.DigestUtils
import net.fabricmc.fabric.impl.build.CommitHashValueSource
import net.fabricmc.fabric.impl.build.GitBranchValueSource
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse

//======================================================================================== GETTING SUBPROJECT VERSIONS
// 11.0.0+a2b5c9f2ef
def getSubprojectVersion(Project project) {
    // Get the version from the gradle.properties file
    def version = project.properties["${project.name}-version"]

    if (!version) {
        throw new NullPointerException("Could not find version for " + project.name)
    }

    def isCi = providers.environmentVariable("CI").present || project.hasProperty("ci")

    if (!isCi) {
        return version + "+local"
    }

    def hashProvider = project.providers.of(CommitHashValueSource.class) {
        parameters.directory = project.name
    }

    def fullHash = ""

    try {
        fullHash = hashProvider.get()
    } catch (Exception e) {
        logger.warn("Could not get commit hash for project ${project.name}: " + e.getMessage())
        fullHash = ""
    }

    def shortHash
    if (fullHash && fullHash.length() >= 8) {
        shortHash = fullHash.substring(0, 8)
    } else if (fullHash && fullHash.length() > 0) {
        // hash exists but is shorter than 8 (rare)
        shortHash = fullHash
    } else {
        shortHash = "unknown"
        logger.warn("Using fallback version suffix for ${project.name} because no commit hash could be determined.")
    }

    def mcVersion = project.rootProject.properties['minecraft_version']

    if(!mcVersion)
    {
        logger.error("FATAL: 'minecraft_version' property not found on the root project")
        mcVersion = "unknownMC"
    }

    return version + "+MC-${mcVersion}"//-" + shortHash
}

//======================================================================================== SETTING UP MODULE DEPENDENCIES
def moduleDependencies(project, List<String> depNames) {
    def deps = depNames.iterator().collect { project.dependencies.project(path: ":$it", configuration: 'namedElements') }
    def clientOutputs = depNames.iterator().collect { findProject(":$it").sourceSets.client.output }

    project.dependencies {
        deps.each {
            api it
        }

        clientOutputs.each {
            clientImplementation it
        }
    }

    def depNodes = deps.collect {
        [
                groupId   : it.group,
                artifactId: it.name,
                version   : getSubprojectVersion(project.project(":" + it.name)),
                scope     : "compile"
        ]
    }

    // As we manually handle the maven artifacts, we need to also manually specify the deps.
    project.publishing {
        publications {
            mavenJava(MavenPublication) {
                pom.withXml {
                    def depsNode = asNode().appendNode("dependencies")

                    for (def depNode in depNodes) {
                        def node = depsNode.appendNode("dependency")

                        for (def entry in depNode) {
                            node.appendNode(entry.key, entry.value)
                        }
                    }
                }
            }
        }
    }
}

//======================================================================================== SETTING UP ALL PROJECTS
allprojects {
    group = "dev.thementor.jilibs"

    apply plugin: "maven-publish"

    tasks.withType(GenerateModuleMetadata).configureEach {
        enabled = false
    }

    publishing {
        setupRepositories(repositories, repsyUrl, repsyUsername, repsyPassword)
    }

    if (metaProjects.contains(it.name)) {
        return
    }

    apply plugin: "java-library"
    apply plugin: "net.fabricmc.fabric-loom"
    apply plugin: "com.diffplug.spotless"

    tasks.withType(JavaCompile).configureEach {
        it.options.release = 25
    }

    java {
        // Must be added before the split source sets are setup.
        withSourcesJar()
    }

    loom {
        splitEnvironmentSourceSets()
        runtimeOnlyLog4j = true
    }

    loom.runs.configureEach {
        vmArgs(debugArgs)
    }

    allprojects.each { p ->
        if (metaProjects.contains(p.name)) {
            return
        }

        loom.mods.register(p.name) {
            sourceSet p.sourceSets.main
            sourceSet p.sourceSets.client
        }
    }

    dependencies {
        minecraft "com.mojang:minecraft:$rootProject.minecraft_version"
        api "net.fabricmc:fabric-loader:${rootProject.loader_version}"
        implementation "net.fabricmc.fabric-api:fabric-api:${rootProject.fabric_version}+${rootProject.minecraft_version.replaceAll('-snapshot.*', '')}"
    }

    tasks.withType(ProcessResources).configureEach {
        inputs.property "version", project.version
        inputs.property "loader_version", rootProject.loader_version
        inputs.property "game_version", rootProject.minecraft_version
        inputs.property "java_version", rootProject.java_version

        filesMatching("fabric.mod.json") {
            expand "version": inputs.properties.version,
                    "loader_version": inputs.properties.loader_version,
                    "game_version": inputs.properties.game_version,
                    "java_version": inputs.properties.java_version
        }
    }

    tasks.withType(AbstractArchiveTask).configureEach {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    // Run this task after updating minecraft to regenerate any required resources
    tasks.register('generateResources') {
        group = "fabric"
    }

    String archivesName = project.base.archivesName.get()
    [jar, sourcesJar].each {
        it.from(rootProject.file("LICENSE")) {
            rename { "${it}-${archivesName}" }
        }
    }

    tasks.register('enigma', net.fabricmc.loom.task.tool.ModEnigmaTask) {
        def clientOnly = file('src/client').exists() && !file('src/main').exists()
        def dir = clientOnly ? file('src/client/resources') : file('src/main/resources')
        mappingFile = new File(dir, project.name + '.mapping')
    }

    tasks.register('validateMixinNames', net.fabricmc.loom.task.ValidateMixinNameTask) {
        source(sourceSets.main.output)
        source(sourceSets.client.output)

        outputs.upToDateWhen { true } // Task has no outputs
    }
    check.dependsOn "validateMixinNames"

    // Apply to each valid subproject.
    apply from: rootProject.file('gradle/package-info.gradle')
    apply from: rootProject.file('gradle/validate-annotations.gradle')

    spotless{
        lineEndings = LineEnding.UNIX

        java{
            licenseHeaderFile(file("${rootDir}/HEADER"))
            removeUnusedImports()
            importOrder('java', 'javax', '', 'net.minecraft', 'net.fabricmc', 'dev.thementor.api', 'dev.thementor')
            leadingTabsToSpaces(4)
            //leadingSpacesToTabs()
            trimTrailingWhitespace()
        }

        groovyGradle{
            target 'src/**/*.gradle', '*.gradle', 'gradle/*.gradle'
            leadingSpacesToTabs()
            leadingTabsToSpaces(4)
            trimTrailingWhitespace()
        }

        json{
            target 'src/**/lang/en_us.json'
            targetExclude 'src/**/generated/**'
            gson().indentWithSpaces(2).sortByKeys()
        }
    }

    build.dependsOn spotlessApply

    //======================================================================================== CUSTOM TASKS

    def destinationDir = layout.buildDirectory.dir("output-sources").get().asFile

    clean.doFirst {
        def versionPattern = version
        def projectSrcDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/SRC")
        def projectModDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/MOD")
        def projectDocDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/DOC")

        println ">>> Starting clean task"
        println ">>> Version To Clean: ${versionPattern}"

        def safeDelete = { File dir ->
            if (dir.exists() && dir.isDirectory()) {
                dir.eachFileRecurse { file ->
                    if (file.isFile()) {
                        if (file.name.contains(versionPattern as CharSequence) && file.name.contains(project.base.archivesName.get())) {
                            file.delete()
                            println ">>> Deleted file: ${file.name}"
                        }
                    }
                }
            } else {
                println ">>> Skipping non-existent or non-directory path: ${dir}"
            }
        }

        safeDelete(projectSrcDir)
        safeDelete(projectModDir)
        safeDelete(projectDocDir)
    }

    tasks.register('copySourceJars', Copy) {
        description = "Copies source JARs from libs to a top-level directory."

        dependsOn remapSourcesJar  // Explicit dependency declaration

        def buildSrcDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/SRC")

        doFirst {
            // Create the destination directory if it doesn't exist
            if (!buildSrcDir.exists()) {
                buildSrcDir.mkdirs()
            }

            println("${it.name} >>> Moving source jar")
        }

        from(layout.buildDirectory.dir("libs").get().asFile){
            include '*-sources.jar'
        }
        into(buildSrcDir)
    }

    tasks.register('copyModJars', Copy) {
        description = "Copies main JARs from libs to a top-level directory."

        dependsOn remapJar  // Explicit dependency declaration

        def buildModDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/MOD")

        doFirst {
            // Create the destination directory if it doesn't exist
            if (!buildModDir.exists()) {
                buildModDir.mkdirs()
            }

            println("${project.name} >>> Moving mod jar")
        }

        from(layout.buildDirectory.dir("libs").get().asFile) {
            include '*.jar'
            exclude '*-sources.jar'
            exclude '*-fatjavadoc.jar'
        }
        into(buildModDir)
    }

    tasks.register('deployToExternalFolder', DefaultTask)
    {
        group = 'build'
        description = "Moves built jars to the external build path."

        dependsOn(copySourceJars, copyModJars)
    }

    tasks.withType(JavaCompile).tap {
        configureEach {
            options.compilerArgs << '-Xlint:unchecked' // show unchecked warnings
            options.compilerArgs << '-Xlint:deprecation' // (optional) also see deprecated warnings
        }
    }
}

logger.lifecycle("==============================================================================")

// Apply auxiliary buildscripts to submodules
// This must be done after all plugins are applied to subprojects
apply from: "gradle/module-versioning.gradle"

//======================================================================================== SETTING UP JAVA DOCS
loom {
    accessWidenerPath = file("gradle/javadoc.accesswidener")
}

javadoc {
    options {
        source = "25"
        encoding = "UTF-8"
        charSet = "UTF-8"
        memberLevel = JavadocMemberLevel.PACKAGE
        // Disable the crazy super-strict doclint tool in Java 8
        addStringOption("Xdoclint:none", "-quiet")

        tags(
                'apiNote:a:API Note:',
                'implSpec:a:Implementation Requirements:',
                'implNote:a:Implementation Note:'
        )
    }

    allprojects.each {
        if (metaProjects.contains(it.name)) {
            return
        }

        source(it.sourceSets.main.allJava)
        source(it.sourceSets.client.allJava)
    }

    classpath = files(sourceSets.main.compileClasspath, sourceSets.client.compileClasspath)
    include("**/api/**")
    failOnError = true
}

tasks.register('javadocJar', Jar) {
    dependsOn javadoc
    from javadoc.destinationDir
    //Set as `fatjavadoc` to prevent an ide form trying to use this javadoc, over using the modules javadoc
    archiveClassifier = "fatjavadoc"
}

build.dependsOn javadocJar

tasks.register('copyDocJars', Copy) {
    description = "Copies source JARs from libs to a top-level directory."

    dependsOn javadocJar  // Explicit dependency declaration

    def buildSrcDir = file("${rootProject.file("./")}/_BUILDS_/${project.name}/DOC")

    doFirst {
        // Create the destination directory if it doesn't exist
        if (!buildSrcDir.exists()) {
            buildSrcDir.mkdirs()
        }

        println("${it.name} >>> Moving source jar")
    }

    from(layout.buildDirectory.dir("libs").get().asFile){
        include '*-fatjavadoc.jar'
    }
    into(buildSrcDir)
}

tasks.named('jar').configure {
    finalizedBy(copyDocJars)
}

//======================================================================================== POM MOD METADATA INFORMATION
def addPomMetadataInformation(Project project, MavenPom pom) {
    def modJsonFile = project.file("src/main/resources/fabric.mod.json")

    if (!modJsonFile.exists()) {
        modJsonFile = project.file("src/client/resources/fabric.mod.json")
    }

    def modJson = new JsonSlurper().parse(modJsonFile)
    pom.name = modJson.name
    pom.url = "https://github.com/drkhodakarami/JiLibs/tree/HEAD/${project.rootDir.relativePath(project.projectDir)}"
    pom.description = modJson.description
    pom.licenses {
        license {
            name = "MIT"
            url = "https://opensource.org/license/mit"
        }
    }
    pom.developers {
        developer {
            name = "TheMentor"
            url = "https://www.youtube.com/@TheMentorCodeLab"
        }
    }
    pom.scm {
        connection = "scm:git:https://github.com/drkhodakarami/JiLibs.git"
        url = "https://github.com/drkhodakarami/JiLibs"
        developerConnection = "scm:git:git@github.com:drkhodakarami/JiLibs.git"
    }
    pom.issueManagement {
        system = "GitHub"
        url = "https://github.com/drkhodakarami/JiLibs/issues"
    }
}

//======================================================================================== SETUP SUB PROJECTS

subprojects {
    if (metaProjects.contains(it.name)) {
        return
    }

    base {
        archivesName = project.name
    }

    dependencies {
        // Make all modules depend on the shared api
        if (project.name != "jilibs-shared") {
            implementation project(path: ':jilibs-shared', configuration: 'namedElements')
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                pom {
                    addPomMetadataInformation(project, pom)
                }
                artifact(tasks.jar.archiveFile) {
                    builtBy(tasks.jar)
                }

                artifact(tasks.sourcesJar) {
                    builtBy tasks.sourcesJar
                }
            }
        }
    }

    def projectName = it.name
    def projectVersion = getSubprojectVersion(it)

    // Log the computed version once per subproject
    logger.lifecycle(">>> >>> >>> >>> >>> >>> ${projectName} Version: ${projectVersion}")

    // Skip publishing if the artifact already exists on the maven server
    tasks.withType(PublishToMavenRepository).configureEach {
        onlyIf {
            if (!repsyUrl) {
                // Always try to publish if the maven url is not set (e.g locally)
                return true
            }

            //https://repo.repsy.io/mvn/TheMentor/jilibs
            def artifactPath = repsyUrl + "/${projectName}/${projectVersion}/${projectName}-${projectVersion}.pom"

            boolean exists = HttpClient.newHttpClient().withCloseable { client ->
                def request = HttpRequest.newBuilder()
                        .uri(URI.create(artifactPath))
                        .method("HEAD", HttpRequest.BodyPublishers.noBody())
                        .build()

                def response = client.send(request, HttpResponse.BodyHandlers.discarding())
                response.statusCode() == 200
            }

            if (exists) {
                logger.lifecycle("${projectName}-${projectVersion}.pom has already been published")
            } else {
                logger.lifecycle("${projectName}-${projectVersion}.pom does not exist, publishing")
            }

            return !exists
        }
    }

    // We manually handle the pom generation
    loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

    javadoc.enabled = false
}

logger.lifecycle("==============================================================================")

//======================================================================================== SETTING UP PUBLISHING TO MAVEN

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact(tasks.jar.archiveFile) {
                builtBy(tasks.jar)
            }

            artifact(tasks.sourcesJar) {
                builtBy tasks.sourcesJar
            }

            artifact javadocJar

            pom {
                addPomMetadataInformation(rootProject, pom)
            }

            List<Map<String, String>> dependencies = []

            subprojects.each {

                if (metaProjects.contains(it.name)) {
                    return
                }

                dependencies.add([
                        'groupId': it.group,
                        'artifactId': it.name,
                        'version': getSubprojectVersion(it),
                        'scope': 'compile'
                ])
            }

            pom.withXml {
                def depsNode = asNode().appendNode("dependencies")
                for (dep in dependencies) {
                    def depNode = depsNode.appendNode("dependency")
                    depNode.appendNode("groupId", dep['groupId'])
                    depNode.appendNode("artifactId", dep['artifactId'])
                    depNode.appendNode("version", dep['version'])
                    depNode.appendNode("scope", dep['scope'])
                }
            }
        }
    }
}

// Required until the deprecation is removed. Fabric API's main jar that is published to maven does not contain sub modules.
loom.disableDeprecatedPomGeneration(publishing.publications.mavenJava)

//======================================================================================== SETTING UP PUBLISHING REPOSITORY
void setupRepositories(RepositoryHandler repositories, String repsyUrl, String repsyUsername, String repsyPassword) {
    //===================================================== >>> LOCAL MAVEN <<<
    repositories.mavenLocal() // uncomment for testing
    if (repsyUrl) {
        repositories.maven {
            url = repsyUrl
            credentials {
                username = repsyUsername
                password = repsyPassword
            }
        }
    }
}

//======================================================================================== SETTING UP SUB PROJECT DEPENDENCY ON MAIN
//This will be used for "game test" and "client game test" modular projects
def devOnlyModules = []

dependencies {
    afterEvaluate {
        subprojects.each {
            if (metaProjects.contains(it.name)) {
                return
            }

            api project(path: "${it.path}")
            clientImplementation project("${it.path}:").sourceSets.client.output
        }
    }
}

configurations {
    nestedJars {
        transitive = false
    }
}

dependencies {
    subprojects.each {
        if (it.name in devOnlyModules || metaProjects.contains(it.name)) {
            return
        }

        nestedJars project("${it.path}")
    }
}

loom.nestJars(tasks.named("jar"), configurations.nestedJars)

//======================================================================================== FILE NAME SANITY CHECK
// Attempt to create a single jar with all files from all nested jars, this will fail if there are duplicate files.
tasks.register("checkNoDuplicateFiles", Zip) {
    inputs.files configurations.nestedJars
    destinationDirectory = layout.buildDirectory.dir("test")

    from {
        configurations.nestedJars.files.collect { zipTree(it) }
    }

    // We expect these files to be duplicated, so exclude them.
    exclude 'META-INF/**'
    exclude 'fabric.mod.json'
}

check.dependsOn "checkNoDuplicateFiles"

//======================================================================================== RELEASE VERSION SANITY CHECK
// A task to ensure that the version being released has not already been released.
tasks.register('checkVersion') {
    doFirst {
        def xml = new URL(repsyUrl + "/jilibs/maven-metadata.xml").text
        def metadata = new groovy.xml.XmlSlurper().parseText(xml)
        def versions = metadata.versioning.versions.version*.text();
        if (versions.contains(version)) {
            throw new RuntimeException("${version} has already been released!")
        }
    }
}

//tasks.publishMods.dependsOn checkVersion
//publish.mustRunAfter checkVersion